//
// File generated by HDevelop for HALCON/.NET (C#) Version 12.0.2
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    if (HalconAPI.isWindows)
      HOperatorSet.SetSystem("use_window_thread","true");
    action();
  }
#endif

  HObject  Image = null;
  HObject ExpGetGlobalVar_Image()
  {
    return Image;
  }
  void ExpSetGlobalVar_Image(HObject obj)
  {
    if (Image!=null)
      Image.Dispose();
    Image = obj;
  }

  // Procedures 
  // Chapter: Matching / Shape-Based
  // Short Description: Display the results of Shape-Based Matching. 
  public void dev_display_shape_matching_results (HTuple hv_ModelID, HTuple hv_Color, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC, 
      HTuple hv_Model)
  {



        // Local iconic variables 

        HObject ho_ModelContours=null, ho_ContoursAffinTrans=null;

        // Local control variables 

        HTuple hv_NumMatches = null, hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_HomMat2DTranslate = new HTuple();
        HTuple   hv_Model_COPY_INP_TMP = hv_Model.Clone();
        HTuple   hv_ScaleC_COPY_INP_TMP = hv_ScaleC.Clone();
        HTuple   hv_ScaleR_COPY_INP_TMP = hv_ScaleR.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);
        try
        {
      //This procedure displays the results of Shape-Based Matching.
      //
      hv_NumMatches = new HTuple(hv_Row.TupleLength());
      if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
      {
        if ((int)(new HTuple((new HTuple(hv_ScaleR_COPY_INP_TMP.TupleLength())).TupleEqual(
            1))) != 0)
        {
          HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleR_COPY_INP_TMP, out hv_ScaleR_COPY_INP_TMP);
        }
        if ((int)(new HTuple((new HTuple(hv_ScaleC_COPY_INP_TMP.TupleLength())).TupleEqual(
            1))) != 0)
        {
          HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleC_COPY_INP_TMP, out hv_ScaleC_COPY_INP_TMP);
        }
        if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
            0))) != 0)
        {
          HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
        }
        else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
            )).TupleEqual(1))) != 0)
        {
          HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out hv_Model_COPY_INP_TMP);
        }
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ModelID.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          ho_ModelContours.Dispose();
          HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID.TupleSelect(
              hv_Index), 1);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                hv_Index%(new HTuple(hv_Color.TupleLength()))));
          }
          HTuple end_val18 = hv_NumMatches-1;
          HTuple step_val18 = 1;
          for (hv_Match=0; hv_Match.Continue(end_val18, step_val18); hv_Match = hv_Match.TupleAdd(step_val18))
          {
            if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
                hv_Match)))) != 0)
            {
              HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
              HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_ScaleR_COPY_INP_TMP.TupleSelect(
                  hv_Match), hv_ScaleC_COPY_INP_TMP.TupleSelect(hv_Match), 0, 0, 
                  out hv_HomMat2DScale);
              HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, hv_Angle.TupleSelect(
                  hv_Match), 0, 0, out hv_HomMat2DRotate);
              HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                  hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
              ho_ContoursAffinTrans.Dispose();
              HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans, 
                  hv_HomMat2DTranslate);
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                    );
              }
            }
          }
        }
      }
      ho_ModelContours.Dispose();
      ho_ContoursAffinTrans.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ModelContours.Dispose();
      ho_ContoursAffinTrans.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Text
  // Short Description: This procedure writes a text message. 
  public void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
      HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
  {



      // Local iconic variables 

      // Local control variables 

      HTuple hv_M = null, hv_N = null, hv_Red = null;
      HTuple hv_Green = null, hv_Blue = null, hv_RowI1Part = null;
      HTuple hv_ColumnI1Part = null, hv_RowI2Part = null, hv_ColumnI2Part = null;
      HTuple hv_RowIWin = null, hv_ColumnIWin = null, hv_WidthWin = null;
      HTuple hv_HeightWin = null, hv_I = null, hv_RowI = new HTuple();
      HTuple hv_ColumnI = new HTuple(), hv_StringI = new HTuple();
      HTuple hv_MaxAscent = new HTuple(), hv_MaxDescent = new HTuple();
      HTuple hv_MaxWidth = new HTuple(), hv_MaxHeight = new HTuple();
      HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRowI = new HTuple();
      HTuple hv_FactorColumnI = new HTuple(), hv_UseShadow = new HTuple();
      HTuple hv_ShadowColor = new HTuple(), hv_Exception = new HTuple();
      HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
      HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
      HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
      HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
      HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
      HTuple hv_CurrentColor = new HTuple();
      HTuple   hv_Box_COPY_INP_TMP = hv_Box.Clone();
      HTuple   hv_Color_COPY_INP_TMP = hv_Color.Clone();
      HTuple   hv_Column_COPY_INP_TMP = hv_Column.Clone();
      HTuple   hv_Row_COPY_INP_TMP = hv_Row.Clone();
      HTuple   hv_String_COPY_INP_TMP = hv_String.Clone();

      // Initialize local and output iconic variables 
    //This procedure displays text in a graphics window.
    //
    //Input parameters:
    //WindowHandle: The WindowHandle of the graphics window, where
    //   the message should be displayed
    //String: A tuple of strings containing the text message to be displayed
    //CoordSystem: If set to 'window', the text position is given
    //   with respect to the window coordinate system.
    //   If set to 'image', image coordinates are used.
    //   (This may be useful in zoomed images.)
    //Row: The row coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Column: The column coordinate of the desired text position
    //   If set to -1, a default value of 12 is used.
    //   A tuple of values is allowed to display text at different
    //   positions.
    //Color: defines the color of the text as string.
    //   If set to [], '' or 'auto' the currently set color is used.
    //   If a tuple of strings is passed, the colors are used cyclically...
    //   - if |Row| == |Column| == 1: for each new textline
    //   = else for each text position.
    //Box: If Box[0] is set to 'true', the text is written within an orange box.
    //     If set to' false', no box is displayed.
    //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
    //       the text is written in a box of that color.
    //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
    //       'true' -> display a shadow in a default color
    //       'false' -> display no shadow
    //       otherwise -> use given string as color string for the shadow color
    //
    //It is possible to display multiple text strings in a single call.
    //In this case, some restrictions apply:
    //- Multiple text positions can be defined by specifying a tuple
    //  with multiple Row and/or Column coordinates, i.e.:
    //  - |Row| == n, |Column| == n
    //  - |Row| == n, |Column| == 1
    //  - |Row| == 1, |Column| == n
    //- If |Row| == |Column| == 1,
    //  each element of String is display in a new textline.
    //- If multiple positions or specified, the number of Strings
    //  must match the number of positions, i.e.:
    //  - Either |String| == n (each string is displayed at the
    //                          corresponding position),
    //  - or     |String| == 1 (The string is displayed n times).
    //
    if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Color_COPY_INP_TMP = "";
    }
    if ((int)(new HTuple(hv_Box_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
    {
      hv_Box_COPY_INP_TMP = "false";
    }
    //
    //
    //Check conditions
    //
    hv_M = (new HTuple(hv_Row_COPY_INP_TMP.TupleLength()))*(new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
        ));
    hv_N = new HTuple(hv_Row_COPY_INP_TMP.TupleLength());
    if ((int)((new HTuple(hv_M.TupleEqual(0))).TupleOr(new HTuple(hv_String_COPY_INP_TMP.TupleEqual(
        new HTuple())))) != 0)
    {

      return;
    }
    if ((int)(new HTuple(hv_M.TupleNotEqual(1))) != 0)
    {
      //Multiple positions
      //
      //Expand single parameters
      if ((int)(new HTuple((new HTuple(hv_Row_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_N = new HTuple(hv_Column_COPY_INP_TMP.TupleLength());
        HOperatorSet.TupleGenConst(hv_N, hv_Row_COPY_INP_TMP, out hv_Row_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_Column_COPY_INP_TMP, out hv_Column_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_Column_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(new HTuple(hv_Row_COPY_INP_TMP.TupleLength())))) != 0)
      {
        throw new HalconException("Number of elements in Row and Column does not match.");
      }
      if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength())).TupleEqual(
          1))) != 0)
      {
        HOperatorSet.TupleGenConst(hv_N, hv_String_COPY_INP_TMP, out hv_String_COPY_INP_TMP);
      }
      else if ((int)(new HTuple((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
          )).TupleNotEqual(hv_N))) != 0)
      {
        throw new HalconException("Number of elements in Strings does not match number of positions.");
      }
      //
    }
    //
    //Prepare window
    HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
    HOperatorSet.GetPart(hv_WindowHandle, out hv_RowI1Part, out hv_ColumnI1Part, 
        out hv_RowI2Part, out hv_ColumnI2Part);
    HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowIWin, out hv_ColumnIWin, 
        out hv_WidthWin, out hv_HeightWin);
    HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
    //
    //Loop over all positions
    HTuple end_val89 = hv_N-1;
    HTuple step_val89 = 1;
    for (hv_I=0; hv_I.Continue(end_val89, step_val89); hv_I = hv_I.TupleAdd(step_val89))
    {
      hv_RowI = hv_Row_COPY_INP_TMP.TupleSelect(hv_I);
      hv_ColumnI = hv_Column_COPY_INP_TMP.TupleSelect(hv_I);
      //Allow multiple strings for a single position.
      if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
      {
        hv_StringI = hv_String_COPY_INP_TMP.Clone();
      }
      else
      {
        //In case of multiple positions, only single strings
        //are allowed per position.
        //For line breaks, use \n in this case.
        hv_StringI = hv_String_COPY_INP_TMP.TupleSelect(hv_I);
      }
      //Default settings
      //-1 is mapped to 12.
      if ((int)(new HTuple(hv_RowI.TupleEqual(-1))) != 0)
      {
        hv_RowI = 12;
      }
      if ((int)(new HTuple(hv_ColumnI.TupleEqual(-1))) != 0)
      {
        hv_ColumnI = 12;
      }
      //
      //Split string into one string per line.
      hv_StringI = (((""+hv_StringI)+"")).TupleSplit("\n");
      //
      //Estimate extentions of text depending on font size.
      HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent, 
          out hv_MaxWidth, out hv_MaxHeight);
      if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
      {
        hv_R1 = hv_RowI.Clone();
        hv_C1 = hv_ColumnI.Clone();
      }
      else
      {
        //Transform image to window coordinates.
        hv_FactorRowI = (1.0*hv_HeightWin)/((hv_RowI2Part-hv_RowI1Part)+1);
        hv_FactorColumnI = (1.0*hv_WidthWin)/((hv_ColumnI2Part-hv_ColumnI1Part)+1);
        hv_R1 = (((hv_RowI-hv_RowI1Part)+0.5)*hv_FactorRowI)-0.5;
        hv_C1 = (((hv_ColumnI-hv_ColumnI1Part)+0.5)*hv_FactorColumnI)-0.5;
      }
      //
      //Display text box depending on text size.
      hv_UseShadow = 1;
      hv_ShadowColor = "gray";
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
      {
        if (hv_Box_COPY_INP_TMP == null)
          hv_Box_COPY_INP_TMP = new HTuple();
        hv_Box_COPY_INP_TMP[0] = "#fce9d4";
        hv_ShadowColor = "#f28d26";
      }
      if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
        {
          //Use default ShadowColor set above
        }
        else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
            "false"))) != 0)
        {
          hv_UseShadow = 0;
        }
        else
        {
          hv_ShadowColor = hv_Box_COPY_INP_TMP.TupleSelect(1);
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                1));
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = new HTuple("Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)");
            throw new HalconException(hv_Exception);
          }
        }
      }
      if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
      {
        //Valid color?
        try
        {
          HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
              0));
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_Exception = new HTuple("Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)");
          throw new HalconException(hv_Exception);
        }
        //Calculate box extents
        hv_StringI = (" "+hv_StringI)+" ";
        hv_Width = new HTuple();
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          HOperatorSet.GetStringExtents(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index), 
              out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
          hv_Width = hv_Width.TupleConcat(hv_W);
        }
        hv_FrameHeight = hv_MaxHeight*(new HTuple(hv_StringI.TupleLength()));
        hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
        hv_R2 = hv_R1+hv_FrameHeight;
        hv_C2 = hv_C1+hv_FrameWidth;
        //Display rectangles
        HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
        HOperatorSet.SetDraw(hv_WindowHandle, "fill");
        //Set shadow color
        HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
        if ((int)(hv_UseShadow) != 0)
        {
          HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, 
              hv_C2+1);
        }
        //Set box color
        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
        HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
        HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
      }
      //Write text.
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_StringI.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        //Set color
        if ((int)(new HTuple(hv_N.TupleEqual(1))) != 0)
        {
          //Wiht a single text position, each text line
          //may get a different color.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        else
        {
          //With multiple text positions, each position
          //gets a single color for all text lines.
          hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_I%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
              )));
        }
        if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
            "auto")))) != 0)
        {
          //Valid color?
          try
          {
            HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            hv_Exception = ((("Wrong value of control parameter Color["+(hv_Index%(new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                ))))+"] == '")+hv_CurrentColor)+"' (must be a valid color string)";
            throw new HalconException(hv_Exception);
          }
        }
        else
        {
          HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        }
        //Finally display text
        hv_RowI = hv_R1+(hv_MaxHeight*hv_Index);
        HOperatorSet.SetTposition(hv_WindowHandle, hv_RowI, hv_C1);
        HOperatorSet.WriteString(hv_WindowHandle, hv_StringI.TupleSelect(hv_Index));
      }
    }
    //Reset changed window settings
    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    HOperatorSet.SetPart(hv_WindowHandle, hv_RowI1Part, hv_ColumnI1Part, hv_RowI2Part, 
        hv_ColumnI2Part);

    return;
  }

  // Local procedures 
  // Chapter: Example
  // Short Description: Async image acquisition loop to be used at the beginning of example program 
  public void abshear_async_acquisition (HTuple hv_WindowHandle, HTuple hv_AcqHandle)
  {



    // Local iconic variables 

    HObject ExpTmpLocalVar_Image=null;

    // Local control variables 

    HTuple hv_keepGrabbing = null, hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Button = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ErrorCode = new HTuple();
    // Initialize local and output iconic variables 
    //global object Image
    hv_keepGrabbing = 1;
    HOperatorSet.GrabImageStart(hv_AcqHandle, -1);

    while ((int)(hv_keepGrabbing) != 0)
    {
      HOperatorSet.GrabImageAsync(out ExpTmpLocalVar_Image, hv_AcqHandle, -1);
      ExpSetGlobalVar_Image(ExpTmpLocalVar_Image);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ExpGetGlobalVar_Image(), HDevWindowStack.GetActive()
            );
      }
      HOperatorSet.WriteString(hv_WindowHandle, "Press Left Mouse Button to Begin...");

      try
      {
        HOperatorSet.GetMposition(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Button);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_ErrorCode = hv_Exception.TupleSelect(0);
      }
      if ((int)(new HTuple(hv_Button.TupleEqual(1))) != 0)
      {
        hv_keepGrabbing = 0;
      }
    }


    return;
  }

  public void abshear_wait_for_mouse_click (HTuple hv_continueAcquisition, HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Button = null, hv_dummy = null;
    HTuple   hv_continueAcquisition_COPY_INP_TMP = hv_continueAcquisition.Clone();

    // Initialize local and output iconic variables 
    hv_Button = 0;
    HOperatorSet.GetMbutton(hv_WindowHandle, out hv_dummy, out hv_dummy, out hv_Button);
    hv_continueAcquisition_COPY_INP_TMP = 0;

    return;
  }

  // Chapter: Example
  // Short Description: Serializes and saves the shape model and corresponding image 
  public void abshear_serialize_and_save (HObject ho_SmoothedImage, HTuple hv_ModelID)
  {




    // Local control variables 

    HTuple hv_SerializedItemHandle = null, hv_SerializedImageHandle = null;
    HTuple hv_FileHandle1 = null, hv_FileHandle2 = null;
    // Initialize local and output iconic variables 

    HOperatorSet.SerializeShapeModel(hv_ModelID, out hv_SerializedItemHandle);
    HOperatorSet.SerializeImage(ho_SmoothedImage, out hv_SerializedImageHandle);

    HOperatorSet.OpenFile("shapeModel.bin", "output_binary", out hv_FileHandle1);
    HOperatorSet.OpenFile("image.bin", "output_binary", out hv_FileHandle2);

    HOperatorSet.FwriteSerializedItem(hv_FileHandle1, hv_SerializedItemHandle);
    HOperatorSet.FwriteSerializedItem(hv_FileHandle2, hv_SerializedImageHandle);

    HOperatorSet.CloseFile(hv_FileHandle1);
    HOperatorSet.CloseFile(hv_FileHandle2);


    return;
  }

#if !NO_EXPORT_MAIN
  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Region, ho_SmoothedImage, ho_ReducedImage;
    HObject ho_ModelImages, ho_ModelRegions, ho_ConnectedRegions;
    HObject ho_SelectedRegions, ho_ModelContours, ho_TestImage=null;

    // Local control variables 

    HTuple hv_WindowHandle = null, hv_Colors = null;
    HTuple hv_MinScore = null, hv_NumMatches = null, hv_AcqHandle = null;
    HTuple hv_Size = null, hv_Coeffs = null, hv_ModelID = null;
    HTuple hv_NumLevels = null, hv_AngleStart = null, hv_AngleExtent = null;
    HTuple hv_AngleStep = null, hv_ScaleMin = null, hv_ScaleMax = null;
    HTuple hv_ScaleStep = null, hv_Metric = null, hv_MinContrast = null;
    HTuple hv_keepGrabbing = null, hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Button = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_ErrorCode = new HTuple(), hv_Angle = new HTuple();
    HTuple hv_Score = new HTuple(), hv_ScoreLength = new HTuple();
    HTuple hv_BestMatchScore = new HTuple(), hv_location = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    HOperatorSet.GenEmptyObj(out ho_SmoothedImage);
    HOperatorSet.GenEmptyObj(out ho_ReducedImage);
    HOperatorSet.GenEmptyObj(out ho_ModelImages);
    HOperatorSet.GenEmptyObj(out ho_ModelRegions);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_ModelContours);
    HOperatorSet.GenEmptyObj(out ho_TestImage);
    try
    {
      // import(...); only in hdevelop
      // import(...); only in hdevelop

      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      HOperatorSet.SetWindowAttr("background_color","white");
      HOperatorSet.OpenWindow(0,0,1024,768,0,"","",out hv_WindowHandle);
      HDevWindowStack.Push(hv_WindowHandle);
      // dev_update_time(...); only in hdevelop
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
      }
      hv_Colors = new HTuple();
      hv_Colors[0] = "red";
      hv_Colors[1] = "green";
      hv_Colors[2] = "cyan";
      hv_MinScore = 0.5;
      hv_NumMatches = 1;

      //global object Image


      HOperatorSet.OpenFramegrabber("GigEVision", 0, 0, 0, 0, 0, 0, "default", -1, 
          "default", -1, "false", "default", "00111cf51192_SENSORTECHNOLOGYCOLTD_STCGE83A", 
          0, -1, out hv_AcqHandle);
      HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "ExposureTimeRaw", 9000);
      disp_message(hv_WindowHandle, "Press F5 to begin live grab. Press Left mouse click to exit live acquisition...", 
          "window", -1, -1, "black", "true");
      // stop(...); only in hdevelop
      abshear_async_acquisition(hv_WindowHandle, hv_AcqHandle);
      disp_message(hv_WindowHandle, "Hold down Left Mouse Button to select region", 
          "window", -1, -1, "black", "true");

      ho_Region.Dispose();
      HOperatorSet.DrawRegion(out ho_Region, hv_WindowHandle);

      HOperatorSet.InfoSmooth("deriche2", 0.3, out hv_Size, out hv_Coeffs);
      ho_SmoothedImage.Dispose();
      HOperatorSet.SmoothImage(ExpGetGlobalVar_Image(), out ho_SmoothedImage, "deriche2", 
          0.3);

      ho_ReducedImage.Dispose();
      HOperatorSet.ReduceDomain(ho_SmoothedImage, ho_Region, out ho_ReducedImage);

      ho_ModelImages.Dispose();ho_ModelRegions.Dispose();
      HOperatorSet.InspectShapeModel(ho_ReducedImage, out ho_ModelImages, out ho_ModelRegions, 
          1, 160);

      //Since the shape models contain a few extraneous edges, they will be
      //removed here to give a slightly nicer visualization.
      ho_ConnectedRegions.Dispose();
      HOperatorSet.Connection(ho_ModelRegions, out ho_ConnectedRegions);
      ho_SelectedRegions.Dispose();
      HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area", 
          "and", 20, 100000);
      ho_ModelRegions.Dispose();
      HOperatorSet.Union1(ho_SelectedRegions, out ho_ModelRegions);
      ho_ModelContours.Dispose();
      HOperatorSet.GenContoursSkeletonXld(ho_ModelRegions, out ho_ModelContours, 
          1, "filter");

      HOperatorSet.CreateShapeModel(ho_ReducedImage, "auto", -0.39, 0.79, "auto", 
          "auto", "use_polarity", "auto", "auto", out hv_ModelID);
      HOperatorSet.GetShapeModelParams(hv_ModelID, out hv_NumLevels, out hv_AngleStart, 
          out hv_AngleExtent, out hv_AngleStep, out hv_ScaleMin, out hv_ScaleMax, 
          out hv_ScaleStep, out hv_Metric, out hv_MinContrast);

      abshear_serialize_and_save(ho_SmoothedImage, hv_ModelID);

      hv_keepGrabbing = 1;
      while ((int)(hv_keepGrabbing) != 0)
      {

        try
        {
          HOperatorSet.GetMposition(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Button);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_ErrorCode = hv_Exception.TupleSelect(0);
        }

        if ((int)(new HTuple(hv_Button.TupleEqual(1))) != 0)
        {
          hv_keepGrabbing = 0;
        }

        //Grab and display an image for the matching
        ho_TestImage.Dispose();
        HOperatorSet.GrabImageAsync(out ho_TestImage, hv_AcqHandle, -1);
        ho_SmoothedImage.Dispose();
        HOperatorSet.SmoothImage(ho_TestImage, out ho_SmoothedImage, "deriche2", 
            0.3);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_TestImage, HDevWindowStack.GetActive());
        }
        HOperatorSet.FindShapeModel(ho_TestImage, hv_ModelID, -0.39, 0.79, hv_MinScore, 
            hv_NumMatches, 0.5, "least_squares", 0, 0.9, out hv_Row, out hv_Column, 
            out hv_Angle, out hv_Score);

        HDevWindowStack.SetActive(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
        }

        dev_display_shape_matching_results(hv_ModelID, "green", hv_Row, hv_Column, 
            hv_Angle, 1.0, 1.0, 0);
        HOperatorSet.TupleLength(hv_Score, out hv_ScoreLength);
        if ((int)(new HTuple(hv_ScoreLength.TupleGreater(0))) != 0)
        {
          HOperatorSet.TupleFirstN(hv_Score, 0, out hv_BestMatchScore);
          disp_message(hv_WindowHandle, "BestMatch: "+hv_BestMatchScore, "window", 
              -1, -1, "black", "true");
          hv_location = (("Location: "+hv_Row)+new HTuple(", "))+hv_Column;
          disp_message(hv_WindowHandle, hv_location, "window", 40, -1, "black", "true");
        }
        else
        {
          disp_message(hv_WindowHandle, "No match found...", "window", -1, -1, "black", 
              "true");
        }

      }

      HOperatorSet.CloseFramegrabber(hv_AcqHandle);

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Region.Dispose();
      ho_SmoothedImage.Dispose();
      ho_ReducedImage.Dispose();
      ho_ModelImages.Dispose();
      ho_ModelRegions.Dispose();
      ho_ConnectedRegions.Dispose();
      ho_SelectedRegions.Dispose();
      ho_ModelContours.Dispose();
      ho_TestImage.Dispose();

      throw HDevExpDefaultException;
    }
    ho_Region.Dispose();
    ho_SmoothedImage.Dispose();
    ho_ReducedImage.Dispose();
    ho_ModelImages.Dispose();
    ho_ModelRegions.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions.Dispose();
    ho_ModelContours.Dispose();
    ho_TestImage.Dispose();

  }

#endif


}
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

